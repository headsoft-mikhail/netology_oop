## Комментарии
1. Разделил проект на 2 файла: описание классов и функций (university) и вызов фунций (main).
1. При рассмотрении предложенных классов, принял решение создать их как дочерние от классов оценщиков - EvaluatingPerson и оцениваемых людей RatedPerson, которые в свою очередь наследуются от просто Person.  
В EvaluatingPerson реализован метод оценивания кем-то кого-то в зависимости от типов аргументов, в RatedPerson - подсчет средней оценки (по всем дисциплинам и по выбранной) и методы сравнивания друг с другом. В таком случае для подсчета среднего балла на курсе не нужно 2 функции, достаточно одной, одинаковой для лекторов и для студентов. Это при условии, что оценки хранятся одинаково в словарях.
1. Для расчета среднего пользовался statistics.mean
1. Получилось не дословное выполнение задания, включая то, что для поддержания знаний английского языка, вывод делал на английском. А также к примеру, для преподавателей посчитал нужным выводить закрепленные курсы при выполнении print() 
1. При описании init и str вызывается функция super(). Когда родительский класс один, то все было понятно, но к примеру, Lecturer наследуется сразу от Mentor и RatedPerson, и мне была непонятна ситуация когда при выполнении print(lecturer) я получал к примеру:

    >Name: Maral <- из Person  
    >Surname: Kasengaziyeva <- из Person  
    >Average grade: 0 <- из RatedPerson  
    >Attached courses: Python, Java <- из Mentor  

    я ожидал, что к RatedPerson обращения не будет,
    пришлось потратить некоторое время, чтобы понять, что super() возвращает не объект родительского класса, а объект класса, следующего по иерархии для того, для которого вызван метод.   

    mro() для класса Lecturer:
    >[<class 'university.Lecturer'>, <class 'university.Mentor'>, <class 'university.RatedPerson'>, <class 'university.Person'>, <class 'object'>]

    То есть когда внутри Mentor(Person) я вызываю super(), возвращается не Person, а следующий по иерархии RatedPerson, а из него уже - Person.
    И все встало на свои места, но сложилось впечатление, что часто лучше напрямую вызывать метод кродительского класса, а не через super(), иначе можно запутаться.   
    В данном случае вывод получился именно такой как я и хотел, но потом долго пытался разобраться - почему. 
